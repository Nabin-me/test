{"dependencies":[{"name":"tslib","loc":{"line":1,"column":37}},{"name":"lodash-es/clamp","loc":{"line":2,"column":18}},{"name":"./options","loc":{"line":3,"column":24}},{"name":"./utils/","loc":{"line":4,"column":41}},{"name":"./decorators/","loc":{"line":5,"column":26}},{"name":"./track/","loc":{"line":6,"column":33}},{"name":"./geometry/","loc":{"line":7,"column":44}},{"name":"./scrolling/","loc":{"line":8,"column":55}},{"name":"./plugin","loc":{"line":9,"column":29}},{"name":"./events/","loc":{"line":10,"column":31}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Scrollbar = exports.scrollbarMap = undefined;\n\nvar _tslib = require(\"tslib\");\n\nvar _clamp = require(\"lodash-es/clamp\");\n\nvar _clamp2 = _interopRequireDefault(_clamp);\n\nvar _options = require(\"./options\");\n\nvar _utils = require(\"./utils/\");\n\nvar _decorators = require(\"./decorators/\");\n\nvar _track = require(\"./track/\");\n\nvar _geometry = require(\"./geometry/\");\n\nvar _scrolling = require(\"./scrolling/\");\n\nvar _plugin = require(\"./plugin\");\n\nvar _events = require(\"./events/\");\n\nvar eventHandlers = _interopRequireWildcard(_events);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// DO NOT use WeakMap here\n// .getAll() methods requires `scrollbarMap.values()`\nvar scrollbarMap = exports.scrollbarMap = new Map();\nvar Scrollbar = /** @class */function () {\n  function Scrollbar(containerEl, options) {\n    var _this = this;\n    /**\n     * Current scrolling offsets\n     */\n    this.offset = {\n      x: 0,\n      y: 0\n    };\n    /**\n     * Max-allowed scrolling offsets\n     */\n    this.limit = {\n      x: Infinity,\n      y: Infinity\n    };\n    /**\n     * Container bounding rect\n     */\n    this.bounding = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n    // private _observer: ResizeObserver;\n    this._plugins = [];\n    this._momentum = { x: 0, y: 0 };\n    this._listeners = new Set();\n    this.containerEl = containerEl;\n    var contentEl = this.contentEl = document.createElement('div');\n    this.options = new _options.Options(options);\n    // mark as a scroll element\n    containerEl.setAttribute('data-scrollbar', 'true');\n    // make container focusable\n    containerEl.setAttribute('tabindex', '-1');\n    (0, _utils.setStyle)(containerEl, {\n      overflow: 'hidden',\n      outline: 'none'\n    });\n    // enable touch event capturing in IE, see:\n    // https://github.com/idiotWu/smooth-scrollbar/issues/39\n    if (window.navigator.msPointerEnabled) {\n      containerEl.style.msTouchAction = 'none';\n    }\n    // mount content\n    contentEl.className = 'scroll-content';\n    Array.from(containerEl.childNodes).forEach(function (node) {\n      contentEl.appendChild(node);\n    });\n    containerEl.appendChild(contentEl);\n    // attach track\n    this.track = new _track.TrackController(this);\n    // initial measuring\n    this.size = this.getSize();\n    // init plugins\n    this._plugins = (0, _plugin.initPlugins)(this, this.options.plugins);\n    // preserve scroll offset\n    var scrollLeft = containerEl.scrollLeft,\n        scrollTop = containerEl.scrollTop;\n    containerEl.scrollLeft = containerEl.scrollTop = 0;\n    this.setPosition(scrollLeft, scrollTop, {\n      withoutCallbacks: true\n    });\n    // FIXME: update typescript\n    var ResizeObserver = window.ResizeObserver;\n    // observe\n    if (typeof ResizeObserver === 'function') {\n      this._observer = new ResizeObserver(function () {\n        _this.update();\n      });\n      this._observer.observe(contentEl);\n    }\n    scrollbarMap.set(containerEl, this);\n    // wait for DOM ready\n    requestAnimationFrame(function () {\n      _this._init();\n    });\n  }\n  Object.defineProperty(Scrollbar.prototype, \"parent\", {\n    /**\n     * Parent scrollbar\n     */\n    get: function () {\n      var elem = this.containerEl.parentElement;\n      while (elem) {\n        var parentScrollbar = scrollbarMap.get(elem);\n        if (parentScrollbar) {\n          return parentScrollbar;\n        }\n        elem = elem.parentElement;\n      }\n      return null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Scrollbar.prototype, \"scrollTop\", {\n    /**\n     * Gets or sets `scrollbar.offset.y`\n     */\n    get: function () {\n      return this.offset.y;\n    },\n    set: function (y) {\n      this.setPosition(this.scrollLeft, y);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Scrollbar.prototype, \"scrollLeft\", {\n    /**\n     * Gets or sets `scrollbar.offset.x`\n     */\n    get: function () {\n      return this.offset.x;\n    },\n    set: function (x) {\n      this.setPosition(x, this.scrollTop);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Returns the size of the scrollbar container element\n   * and the content wrapper element\n   */\n  Scrollbar.prototype.getSize = function () {\n    return (0, _geometry.getSize)(this);\n  };\n  /**\n   * Forces scrollbar to update geometry infomation.\n   *\n   * By default, scrollbars are automatically updated with `100ms` debounce (or `MutationObserver` fires).\n   * You can call this method to force an update when you modified contents\n   */\n  Scrollbar.prototype.update = function () {\n    (0, _geometry.update)(this);\n    this._plugins.forEach(function (plugin) {\n      plugin.onUpdate();\n    });\n  };\n  /**\n   * Checks if an element is visible in the current view area\n   */\n  Scrollbar.prototype.isVisible = function (elem) {\n    return (0, _geometry.isVisible)(this, elem);\n  };\n  /**\n   * Sets the scrollbar to the given offset without easing\n   */\n  Scrollbar.prototype.setPosition = function (x, y, options) {\n    var _this = this;\n    if (x === void 0) {\n      x = this.offset.x;\n    }\n    if (y === void 0) {\n      y = this.offset.y;\n    }\n    if (options === void 0) {\n      options = {};\n    }\n    var status = (0, _scrolling.setPosition)(this, x, y);\n    if (!status || options.withoutCallbacks) {\n      return;\n    }\n    this._listeners.forEach(function (fn) {\n      fn.call(_this, status);\n    });\n  };\n  /**\n   * Scrolls to given position with easing function\n   */\n  Scrollbar.prototype.scrollTo = function (x, y, duration, options) {\n    if (x === void 0) {\n      x = this.offset.x;\n    }\n    if (y === void 0) {\n      y = this.offset.y;\n    }\n    if (duration === void 0) {\n      duration = 0;\n    }\n    if (options === void 0) {\n      options = {};\n    }\n    (0, _scrolling.scrollTo)(this, x, y, duration, options);\n  };\n  /**\n   * Scrolls the target element into visible area of scrollbar,\n   * likes the DOM method `element.scrollIntoView().\n   */\n  Scrollbar.prototype.scrollIntoView = function (elem, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    (0, _scrolling.scrollIntoView)(this, elem, options);\n  };\n  /**\n   * Adds scrolling listener\n   */\n  Scrollbar.prototype.addListener = function (fn) {\n    if (typeof fn !== 'function') {\n      throw new TypeError('[smooth-scrollbar] scrolling listener should be a function');\n    }\n    this._listeners.add(fn);\n  };\n  /**\n   * Removes listener previously registered with `scrollbar.addListener()`\n   */\n  Scrollbar.prototype.removeListener = function (fn) {\n    this._listeners.delete(fn);\n  };\n  /**\n   * Adds momentum and applys delta transformers.\n   */\n  Scrollbar.prototype.addTransformableMomentum = function (x, y, fromEvent, callback) {\n    this._updateDebounced();\n    var finalDelta = this._plugins.reduce(function (delta, plugin) {\n      return plugin.transformDelta(delta, fromEvent) || delta;\n    }, { x: x, y: y });\n    var willScroll = !this._shouldPropagateMomentum(finalDelta.x, finalDelta.y);\n    if (willScroll) {\n      this.addMomentum(finalDelta.x, finalDelta.y);\n    }\n    if (callback) {\n      callback.call(this, willScroll);\n    }\n  };\n  /**\n   * Increases scrollbar's momentum\n   */\n  Scrollbar.prototype.addMomentum = function (x, y) {\n    this.setMomentum(this._momentum.x + x, this._momentum.y + y);\n  };\n  /**\n   * Sets scrollbar's momentum to given value\n   */\n  Scrollbar.prototype.setMomentum = function (x, y) {\n    if (this.limit.x === 0) {\n      x = 0;\n    }\n    if (this.limit.y === 0) {\n      y = 0;\n    }\n    if (this.options.renderByPixels) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n    this._momentum.x = x;\n    this._momentum.y = y;\n  };\n  /**\n   * Update options for specific plugin\n   *\n   * @param pluginName Name of the plugin\n   * @param [options] An object includes the properties that you want to update\n   */\n  Scrollbar.prototype.updatePluginOptions = function (pluginName, options) {\n    this._plugins.forEach(function (plugin) {\n      if (plugin.name === pluginName) {\n        Object.assign(plugin.options, options);\n      }\n    });\n  };\n  Scrollbar.prototype.destroy = function () {\n    var _a = this,\n        containerEl = _a.containerEl,\n        contentEl = _a.contentEl;\n    (0, _utils.clearEventsOn)(this);\n    this._listeners.clear();\n    this.setMomentum(0, 0);\n    cancelAnimationFrame(this._renderID);\n    if (this._observer) {\n      this._observer.disconnect();\n    }\n    scrollbarMap.delete(this.containerEl);\n    // restore contents\n    var childNodes = Array.from(contentEl.childNodes);\n    while (containerEl.firstChild) {\n      containerEl.removeChild(containerEl.firstChild);\n    }\n    childNodes.forEach(function (el) {\n      containerEl.appendChild(el);\n    });\n    // reset scroll position\n    (0, _utils.setStyle)(containerEl, {\n      overflow: ''\n    });\n    containerEl.scrollTop = this.scrollTop;\n    containerEl.scrollLeft = this.scrollLeft;\n    // invoke plugin.onDestroy\n    this._plugins.forEach(function (plugin) {\n      plugin.onDestroy();\n    });\n    this._plugins.length = 0;\n  };\n  Scrollbar.prototype._init = function () {\n    var _this = this;\n    this.update();\n    // init evet handlers\n    Object.keys(eventHandlers).forEach(function (prop) {\n      eventHandlers[prop](_this);\n    });\n    // invoke `plugin.onInit`\n    this._plugins.forEach(function (plugin) {\n      plugin.onInit();\n    });\n    this._render();\n  };\n  Scrollbar.prototype._updateDebounced = function () {\n    this.update();\n  };\n  // check whether to propagate monmentum to parent scrollbar\n  // the following situations are considered as `true`:\n  //         1. continuous scrolling is enabled (automatically disabled when overscroll is enabled)\n  //         2. scrollbar reaches one side and is not about to scroll on the other direction\n  Scrollbar.prototype._shouldPropagateMomentum = function (deltaX, deltaY) {\n    if (deltaX === void 0) {\n      deltaX = 0;\n    }\n    if (deltaY === void 0) {\n      deltaY = 0;\n    }\n    var _a = this,\n        options = _a.options,\n        offset = _a.offset,\n        limit = _a.limit;\n    if (!options.continuousScrolling) return false;\n    // force an update when scrollbar is \"unscrollable\", see #106\n    if (limit.x === 0 && limit.y === 0) {\n      this._updateDebounced();\n    }\n    var destX = (0, _clamp2.default)(deltaX + offset.x, 0, limit.x);\n    var destY = (0, _clamp2.default)(deltaY + offset.y, 0, limit.y);\n    var res = true;\n    // offsets are not about to change\n    // `&=` operator is not allowed for boolean types\n    res = res && destX === offset.x;\n    res = res && destY === offset.y;\n    // current offsets are on the edge\n    res = res && (offset.x === limit.x || offset.x === 0 || offset.y === limit.y || offset.y === 0);\n    return res;\n  };\n  Scrollbar.prototype._render = function () {\n    var _momentum = this._momentum;\n    if (_momentum.x || _momentum.y) {\n      var nextX = this._nextTick('x');\n      var nextY = this._nextTick('y');\n      _momentum.x = nextX.momentum;\n      _momentum.y = nextY.momentum;\n      this.setPosition(nextX.position, nextY.position);\n    }\n    var remain = (0, _tslib.__assign)({}, this._momentum);\n    this._plugins.forEach(function (plugin) {\n      plugin.onRender(remain);\n    });\n    this._renderID = requestAnimationFrame(this._render.bind(this));\n  };\n  Scrollbar.prototype._nextTick = function (direction) {\n    var _a = this,\n        options = _a.options,\n        offset = _a.offset,\n        _momentum = _a._momentum;\n    var current = offset[direction];\n    var remain = _momentum[direction];\n    if (Math.abs(remain) <= 0.1) {\n      return {\n        momentum: 0,\n        position: current + remain\n      };\n    }\n    var nextMomentum = remain * (1 - options.damping);\n    if (options.renderByPixels) {\n      nextMomentum |= 0;\n    }\n    return {\n      momentum: nextMomentum,\n      position: current + remain - nextMomentum\n    };\n  };\n  (0, _tslib.__decorate)([(0, _decorators.debounce)(100, { leading: true })], Scrollbar.prototype, \"_updateDebounced\", null);\n  return Scrollbar;\n}();\nexports.Scrollbar = Scrollbar;\n//# sourceMappingURL=scrollbar.js.map"},"hash":"e986707667cca791580efd126ed1ea2c"}